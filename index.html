<!DOCTYPE html>
<html>
  <head>
    <link
      rel="stylesheet"
      href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css"
      integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"
      crossorigin="anonymous"
    />
    <link
      rel="stylesheet"
      href="https://openlayers.org/en/v6.1.1/css/ol.css"
    />
    <link
      href="https://fonts.googleapis.com/css?family=Roboto&display=swap"
      rel="stylesheet"
    />

    <link
        rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/all.css"
		integrity="sha256-46qynGAkLSFpVbEBog43gvNhfrOj+BmwXdxFgVK/Kvc="
		crossorigin="anonymous" />

    <style>
      #map {
        background: #202020;
        font-size: 16px;
        font-family: "Roboto", sans-serif;
      }

      body,
      html,
      #map {
        margin: 0px;
        width: 100%;
        height: 100%;
      }

      .layer-select {
        position: absolute;
        top: 0.5em;
        right: 0.5em;
        width: 150px;
      }
    </style>
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  </head>

  <body margin="0" padding="0">
    <script src="https://openlayers.org/en/v6.1.1/build/ol.js"></script>
    <script
      src="https://code.jquery.com/jquery-3.3.1.slim.min.js"
      integrity="sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.7/umd/popper.min.js"
      integrity="sha384-UO2eT0CpHqdSJQ6hJty5KVphtPhzWj9WO1clHTMGa3JDZwrnQq4sF86dIHNDz0W1"
      crossorigin="anonymous"
    ></script>
    <script
      src="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/js/bootstrap.min.js"
      integrity="sha384-JjSmVgyd0p3pXB1rRibZUAYoIIy6OrQ6VrjIEaFf/nJGzIxFDsf4x0xIM+B07jRM"
      crossorigin="anonymous"
    ></script>

    <script src="playersData.js"></script>

    <div id="map"></div>
    <script>
      var layers = {
        dim0: {
          name: "Overworld",
          attribution:
            '<a href="https://github.com/mjungnickel18/papyruscs">PapyrusCS</a>',
          minNativeZoom: 15,
          minZoom: 15,
          maxNativeZoom: 20,
          maxZoom: 22,
          noWrap: true,
          tileSize: 512,
          folder: "dim0",
          fileExtension: "png"
        }
      };

      var config = {
        factor: 1
      };

      layers = {"dim0":{"name":"Overworld","attribution":"Generated by <a href=\"https://github.com/mjungnickel18/papyruscs\">PapyrusCS</a>","minNativeZoom":9,"maxNativeZoom":20,"noWrap":true,"tileSize":512,"folder":"dim0","fileExtension":"webp"},"dim1":{"name":"Nether","attribution":"Generated by <a href=\"https://github.com/mjungnickel18/papyruscs\">PapyrusCS</a>","minNativeZoom":11,"maxNativeZoom":20,"noWrap":true,"tileSize":512,"folder":"dim1","fileExtension":"webp"},"dim2":{"name":"The End","attribution":"Generated by <a href=\"https://github.com/mjungnickel18/papyruscs\">PapyrusCS</a>","minNativeZoom":9,"maxNativeZoom":20,"noWrap":true,"tileSize":512,"folder":"dim2","fileExtension":"webp"}}; 
config = {"factor":65536.0,"globalMinZoom":9,"globalMaxZoom":20,"tileSize":512,"blocksPerTile":32};

      // ======

      // For the extent sizes specified below, OpenLayers tries to fit
      // the whole extents given in a space [0, 0] -> [2^8, 2^8] visually
      // on screen at zoom level 0.
      //
      // This constant represents that internal tile size that OpenLayers
      // will aim for, so that we can calculate zoom levels correctly later.
      const openLayersInternalTileSize = Math.pow(2, 8); // 256

      // The actual size of the tiles that we're using in Papyrus.
      const tileSize = config.tileSize;

      // The maximum positive extents of the whole map. The units for this
      // value are "number of tiles at the most zoomed out level generated
      // by Papyrus". That is, if Papyrus generates a minimum zoom level
      // of 15, then the units for this extent size are the number of (Papyrus)
      // zoom level 15 tiles to display at (OpenLayers) zoom level 0.
      //
      // The minimum zoom level that Papyrus is using is in config.globalMinZoom.
      const maximumExtentSize = 10000;

      // The minimum negative extents of the whole map. Uses the same units
      // as maximumExtentSize.
      const minimumExtentSize = -10000;

      // Computes the resolutions array to use for OpenLayers. For each OpenLayers
      // zoom level (0 through 42), this computes the ratio such that a single tile
      // at OpenLayers zoom level 0 is a single tile at the minimum Papyrus zoom level.
      const papyrusMinimumZoomScale = Math.pow(2, config.globalMinZoom);
      const convertedFromTilesToPixelsUsingTileSize = papyrusMinimumZoomScale / tileSize;
      const resolutions = new Array(43);
      for (let z = 0; z < 43; ++z) {
        resolutions[z] = convertedFromTilesToPixelsUsingTileSize / Math.pow(2, z);
      }

      // When we calculate resolutions above, we've effectively saying that zoom level 0 is
      // zoom level N, where N is the lowest zoom level. This zoom level N also becomes
      // the range of [0, 0] -> [1, 1] in the coordinate system. We need to be able to translate
      // coordinates in that "zoomed out" coordinate system, back down to the maximum zoom level
      // where each tile represents 32x32 (depending on tilesize) Minecraft tiles.
      const zoomRatioForMaximumZoom = 1 / Math.pow(2, config.globalMaxZoom - config.globalMinZoom);
      const minecraftTilesAtMostZoomedInLevel = config.blocksPerTile;

      // Use a projection where pixels have a 1:1 ratio with the screen at zoom level 0.
      const projection = new ol.proj.Projection({
        code: "ZOOMIFY",
        units: "pixels",
        extent: [
          0,
          0,
          openLayersInternalTileSize / tileSize,
          openLayersInternalTileSize / tileSize
        ]
      });

      // Construct the tile grid using the desired maximum and minimum extents listed above,
      // set the origin to [0, 0] (the center of the map), and the calculated resolutions array.
      const tilegrid = new ol.tilegrid.TileGrid({
        extent: [
          minimumExtentSize,
          minimumExtentSize,
          maximumExtentSize,
          maximumExtentSize
        ],
        origin: [0, 0],
        resolutions: resolutions,
        tileSize: [tileSize, tileSize]
      });

      let map;
      let locationElement;

      const tileLayers = Object.keys(layers)
        .sort()
        .map(function(layerKey, idx) {
          const layer = layers[layerKey];
          const tileLayer = new ol.layer.Tile({
            source: new ol.source.XYZ({
              tileUrlFunction: function(tileCoord, pixelRatio, projection) {
                const z = tileCoord[0];
                const x = tileCoord[1];
                const y = tileCoord[2];
                return (
                  "./" +
                  layer.folder +
                  "/" +
                  z +
                  "/" +
                  x +
                  "/" +
                  y +
                  "." +
                  layer.fileExtension
                );
              },
              projection: projection,
              tileGrid: tilegrid,
              attributions: layer.attribution
            }),
            visible: idx == 0
          });
          tileLayer.metaLayerKey = layerKey;
          return tileLayer;
        });

      const initialLayer = layers[Object.keys(layers).sort()[0]];

      if (Object.keys(layers).sort()[0] == "dim0_stronghold") {
        document.getElementById("map").style.background = "#fff";
      } else {
        document.getElementById("map").style.background = "#202020";
      }
                
      const view = new ol.View({
        projection: projection,
        center: [0, 0],
        zoom: 7,
        minZoom: 0,
        maxZoom: config.globalMaxZoom - config.globalMinZoom
      });

      const PapyrusControls = (function(Control) {
        function PapyrusControls(opt_options) {
          const options = opt_options || {};

          const element = document.createElement("div");
          element.className = "layer-select ol-unselectable";

          const card = document.createElement("div");
          card.className = "card";
          element.appendChild(card);

          const cardBody = document.createElement("div");
          cardBody.className = "card-body p-3 px-3";
          card.appendChild(cardBody);

          const form = document.createElement("form");
          cardBody.appendChild(form);

          let currentSelectedLayer = Object.keys(layers).sort()[0];
          let rememberedCenters = {};
          let rememberedZoom = {};

          Object.keys(layers)
            .sort()
            .forEach(function(layerKey, idx) {
              const layer = layers[layerKey];

              const radioContainer = document.createElement("div");
              radioContainer.className = "custom-control custom-radio";

              const radioInput = document.createElement("input");
              radioInput.type = "radio";
              radioInput.id = layerKey;
              radioInput.name = "layers";
              radioInput.className = "custom-control-input";
              radioInput.checked = idx == 0;
              radioInput.value = layerKey;
              radioContainer.appendChild(radioInput);

              const radioLabel = document.createElement("label");
              radioLabel.htmlFor = layerKey;
              radioLabel.className = "custom-control-label";
              radioLabel.innerText = layer.name;
              radioContainer.appendChild(radioLabel);

              const selectLayer = function(e) {
                if (layerKey == "dim0_stronghold") {
                  document.getElementById("map").style.background = "#fff";
                } else {
                  document.getElementById("map").style.background = "#202020";
                }
        
                if (currentSelectedLayer != layerKey) {
                  const runtimeLayers = map.getLayers();
                  runtimeLayers.forEach(function(runtimeLayer) {
                    runtimeLayer.setVisible(
                      runtimeLayer.metaLayerKey == layerKey
                    );
                  });
                  
                  const oldFocusGroup = currentSelectedLayer.substr(0, 4);
                  const newFocusGroup = layerKey.substr(0, 4);

                  rememberedCenters[oldFocusGroup] = view.getCenter();
                  if (rememberedCenters[newFocusGroup] === undefined) {
                    // refocus the map to 0, 0
                    view.setCenter([0, 0]);
                  } else {
                    // set back to where we were
                    view.setCenter(rememberedCenters[newFocusGroup]);
                  }

                  rememberedZoom[oldFocusGroup] = view.getZoom();
                  view.setMinZoom(layer.minNativeZoom - config.globalMinZoom);
                  view.setMaxZoom(layer.maxNativeZoom - config.globalMinZoom);
                  if (rememberedZoom[newFocusGroup] === undefined) {
                    // rezoom the map to minimum zoom
                    view.setZoom(layer.minNativeZoom - config.globalMinZoom);
                  } else {
                    // set back to where we were
                    view.setZoom(rememberedZoom[newFocusGroup]);
                  }

                  const radios = $("input[name='layers']");
                  radios.each(function(idx, elem) {
                    if (elem.value == layerKey) {
                      elem.checked = true;
                    } else {
                      elem.checked = false;
                    }
                  });

                  currentSelectedLayer = layerKey;                
                }
              };

              radioInput.addEventListener(
                "click",
                selectLayer.bind(this),
                false
              );

              form.appendChild(radioContainer);
            });

          const hr = document.createElement("hr");
          form.appendChild(hr);

          locationElement = document.createElement("div");
          locationElement.innerText = "X: 0, Z: 0";
          form.appendChild(locationElement);

          Control.call(this, {
            element: element,
            target: options.target
          });
        }

        if (Control) PapyrusControls.__proto__ = Control;
        PapyrusControls.prototype = Object.create(Control && Control.prototype);
        PapyrusControls.prototype.constructor = PapyrusControls;

        return PapyrusControls;
      })(ol.control.Control);

      map = new ol.Map({
        target: "map",
        layers: tileLayers,
        view: view,
        controls: [
          new ol.control.Zoom(),
          new ol.control.Attribution(),
          new PapyrusControls()
        ]
      });

      map.on("pointermove", function(event) {
        var x = Math.floor(
          (event.coordinate[0] / zoomRatioForMaximumZoom) *
            minecraftTilesAtMostZoomedInLevel
        );
        var z = Math.floor(
          (-event.coordinate[1] / zoomRatioForMaximumZoom) *
            minecraftTilesAtMostZoomedInLevel
        );

        locationElement.innerText = "X: " + x + " Z: " + z;
      });

      if (typeof(playersData) !== "undefined") {
        var playerFeatures = [];

        for (var playerIndex in playersData.players)
        {
            var player = playersData.players[playerIndex];

            if (!player.visible) {
                continue;
            }

            if (player.dimensionId !== 0) {
                // TODO: Currently I'm only adding player markers who are in the Overworld
                // We'll want to show players depending on which dimension is being viewed
                // Maybe add a separate layer for players in each dimension
                continue;
            }

            var style = new ol.style.Style({
                text: new ol.style.Text({
                    text: player.name + "\n\uf041", // map-marker
                    font: "900 18px 'Font Awesome 5 Free'",
                    textBaseline: "bottom",
                    fill: new ol.style.Fill({color: player.color}),
                    stroke: new ol.style.Stroke({color: "white", width: 2})
                })
            });

            var playerFeature = new ol.Feature({
                geometry: new ol.geom.Point([
                    (player.position[0] * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel,
                    (-player.position[2] * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel
                ])
            });

            playerFeature.setStyle(style);

            playerFeatures.push(playerFeature);
        }

        var vectorSource = new ol.source.Vector({
            features: playerFeatures
        });

        var vectorLayer = new ol.layer.Vector({
            source: vectorSource
        });

        map.addLayer(vectorLayer);
      }
    </script>
    <script>
      // gmpiper 18 November 2020
      //
      // Germ of this script provided by Reddit u/dopazz, 17 November 2020
      //
      // Let's figure out how to create three different sets of coordinates:
      // 1. Regions - high-level areas of the map, viewable from low zoom level
      // 2. Neighborhoods - named areas
      // 3. Structures - features created by Coastal users
      //
      // gmpiper 20 November 2020
      // All Coastal Feature Arrays have the same structure:
      // x-value, z-value, Text1, Text2, Text3, textRotation(degrees), Note
      
      var arrayCoastalPOI = [ // POI = Points of Interest
        [  -61, 80,'\uf13d','Spawn Ship',,,			        ],
        [   32, 101,'\uf13d','Event Ship',,,			        ],
        [   97, 91,'\uf13d','Tim, Tom, Tam','\uf51e,\uf522',,			        ],
        [  365, 1850, '\uf5a2', 'Oh my gold! The irony!','Gold and Iron Farm',,],
        [  420, 1790, '\uf6e8', 'Sugnard the wizard',,, ],
        [  470, 1710, '\uf3a3', 'The Kingdom of Anghip',,, ],
        [ -720, -131, '\uf1bb', 'World Tree',,, ]
      ];
      var arrayCoastalIcons = [
        [ -292,-1572,'\uf64f',,,,'Village'		],
        [  611, -828,'\uf64f',,,,'Village'						],
        [ -648,-1639,'\uf64f',,,,'Village'						],
        [ -269,-1980,'\uf64f',,,,'Village'						],
        [ -726,-2095,'\uf64f',,,,'Village'						]
      ];
      var arrayCoastalPortals = [
        [   0,  0,'\uf557','Spawn Portal',,,   ]
      ];
      var arrayRegions = [
      // array structure: x-value, z-value, label
        [  -80,-87,'Triad Shores',,,,			]
      ];
      var arrayCoastalRetail = [
      // array structure: x-value, z-value, StoreName, Proprietor, GoodsSold
        [   35, -185,'\uf3a5','Blackstar Market - Mazer Blackstar',,,],
        [  579, -763,'\uf3a5','Cat\'s and Canoe\'s - Mazer Blackstar',,,],
        [ -200, -200,'\uf3a5','Mall of Ryloth',,,],
        [  160,  -40,'\uf3a5','Tipped Cow','Beef',,],
        [ -251,   90,'\uf3a5','Leaky Cauldron',,,],
        [ -100,  -33,'\uf3a5','The Lazy Grinders Tower',,,],
        [   36, -124,'\uf3a5','Chop Chop Wood Shop','Logs',,],
        [   44, -100,'\uf3a5','Mesa Supply and Surplus','Terracotta and Sand',,]
      ];
      var arrayBigWater = [
      // array structure: x-value, z-value, WaterFeatureName
        //[  917,-4297,'Great Stone Bay'          ,,,         ,]
      ];
      var arraySmallWater = [
      // array structure: x-value, z-value, WaterFeatureName
          //[  420,   33,'~ Library Passage ~'      ,,, 50.0    ,]
      ];
      var arrayCoastalPeaks = [
          //[  667,  -75,'CoastalMountable'         ,'\u25EE','elev. 223'   ,,]
      ];
      var arrayCoastalDepths = [
          //[ -601,  -34,'Trench of Terror' ,'\u25BD'   ,'elev.  11',,]
      ];
      var arrayCoastalDetails = [
      // These items should only show up at closest zoom
          [ -182, -175,'Blue Bookstore','Enchanted Books',,,], 
          [ -168, -210,'Ubaan Outfitters','Wool',,,],
          [ -178, -201,'Greedy Piglin','Nether Goods',,,],
          [ -185, -208,'Hive Mind','Honey and Flowers',,,],
          [ -193, -188,'End Times','Shulkers & End Goods',,,]
          ];
      // The Coastal array structure:
      // arrayName[0], font[1], fill color[2], stroke color[3], minZoom[4] 
          var arrayCoastal = [
              [arrayRegions   ,"italic    900 20px 'Font Awesome 5 Free'","yellow"   ,"black",3],
              [arrayCoastalPOI    ,"          900 14px 'Font Awesome 5 Free'","white"    ,"black",7],
              [arrayCoastalIcons  ,"          900 18px 'Font Awesome 5 Free'","red"      ,"white",6],
              [arrayCoastalPortals,"          900 18px 'Font Awesome 5 Free'","fuchsia"  ,"black",6],
              [arrayCoastalRetail ,"italic    900 14px 'Font Awesome 5 Free'","teal"   ,"black",7],
              [arrayBigWater  ,"italic    900 16px 'Font Awesome 5 Free'","white"     ,"dodgerblue",5],
              [arraySmallWater,"italic    900 14px 'Font Awesome 5 Free'","white"     ,"dodgerblue",8],
              [arrayCoastalPeaks  ,"          900 14px 'Font Awesome 5 Free'","lime"     ,"black",6],
              [arrayCoastalDepths ,"          900 14px 'Font Awesome 5 Free'","darkblue" ,"orange",6],
              [arrayCoastalDetails,"italic    900 12px 'Font Awesome 5 Free'","teal"   ,"black",9],
          ];
          for (i=0; i < arrayCoastal.length; i++) {
          //create array to hold the marker points
          var markerFeatures = [];
          var j;
          for (j=0; j < arrayCoastal[i][0].length; j++) {
              //build the text of the label
              var textLine1 = arrayCoastal[i][0][j][2];
              var textLine2 = arrayCoastal[i][0][j][3];
              var textLine3 = arrayCoastal[i][0][j][4];
              var textLines = textLine1;
              if (textLine2){
                  textLines = textLines + "\n" + textLine2
              };
              if (textLine3){
                  textLines = textLines + "\n" + textLine3
              };
              var rotDegrees = arrayCoastal[i][0][j][5];
              if (rotDegrees){
                  rotRadians = ((rotDegrees * 3.14) / 180.0)
              } else {
                  rotRadians = 0.0
              };
            //define a style for the marker
            var style = new ol.style.Style({
              text: new ol.style.Text({
                text: textLines,
                // font: "900 14px 'Font Awesome 5 Free'",
                // font: "400 16px 'Font Awesome 5 Free'",
                font: arrayCoastal[i][1],
                textBaseline: "center",
                rotation: rotRadians,
                fill: new ol.style.Fill({color: arrayCoastal[i][2]}),
                // backgroundFill: new ol.style.Fill({color: "black"})
                stroke: new ol.style.Stroke({color: arrayCoastal[i][3], width: 3})
              })
            });
            //using the coordinate conversion formula that PapyrusCS uses for player positions, create a point at -23, 25.
            var markerFeature = new ol.Feature({
              geometry: new ol.geom.Point([
                    (arrayCoastal[i][0][j][0] * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel,
                    (arrayCoastal[i][0][j][1] * -1 * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel
              ])
            });
            //apply the style
            markerFeature.setStyle(style);
            //push the constructed marker feature into the array
            markerFeatures.push(markerFeature);
          } // end for j
          //create an OpenLayer source from the feature array
          var markerSource = new ol.source.Vector({
            features: markerFeatures
          });
          //create an OpenLayer vector layer from the source, set a minZoom so we only see the marker when zoomed in.
          var markerLayer = new ol.layer.Vector({
            minZoom: arrayCoastal[i][4],
            source: markerSource
          });
          //add the layer
          map.addLayer(markerLayer);
          } // end for i
          
  // ***********************************************************************
  
//  var arrayLineTunnels = [ // group of lines sharing features (color,weight,style)
      //[
      //    'Great Stone Bay Tunnel', // name of line
      //    [  860.0,-4191.0],// x,z of line start
      //    [  968.0,-4191.0] // x,z of line end
     // ]
//  ];
//  var arrayLineOver = [
      //[
     //     'Snappy Shuttle',
     //     [  648.0, -768.0],
      //    [  648.0, -109.0]
      //]
//  ];
//  var arrayLineUndergroundWaterway = [
    //  [
    //      'Grand Central Inlet',
    //      [  689.0,  119.0],
    //      [  689.0,  -72.0]
    //  ],
    //  [
    //      'Grand Central Inlet',
    //      [  687.0,  119.0],
    //      [  687.0,  -72.0]
     // ],
    //  [
    //      'Grand Central Inlet',
    //      [  687.0,  -72.0],
    //      [  689.0,  -72.0]
    //  ],
    //  [
    //      'Submarine Base',
    //      [  577.0,  311.0],
    //      [  538.0,  311.0]
    //  ],
    //  [
    //      'Submarine Base',
    //      [  577.0,  327.0],
    //      [  538.0,  327.0]
    //  ],
    //  [
    //      'Submarine Base',
    //      [  538.0,  311.0],
    //      [  538.0,  327.0]
    //  ]
//  ];
  
//  var arrayLines = [ // array of all line groups and their line styles
  // Format: arrayLine name, stroke color, stroke weight, line dash
    //  [arrayLineTunnels               ,"yellow"       ,"3",[10,5]],
    //  [arrayLineOver                  ,"darkgray"     ,"1",[10,5]],
    //  [arrayLineUndergroundWaterway   ,"dodgerblue"   ,"1",[10,5]]
//  ];
  
//  for (i=0; i < arrayLines.length; i++) {
//      for (j=0; j < arrayLines[i][0].length; j++) {
//          linePoints = [
//              [(arrayLines[i][0][j][1][0] * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel,
//            (arrayLines[i][0][j][1][1] * -1 * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel
//            ],
//              [(arrayLines[i][0][j][2][0] * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel,
//            (arrayLines[i][0][j][2][1] * -1 * zoomRatioForMaximumZoom) / minecraftTilesAtMostZoomedInLevel
//            ]
 //         ];
 //         var featureLine = new ol.Feature({
//              geometry: new ol.geom.LineString(linePoints)
//          });
//          var vectorLine = new ol.source.Vector({});
//          vectorLine.addFeature(featureLine);
//  
//          var vectorLineLayer = new ol.layer.Vector({
//              source: vectorLine,
//              minZoom: 7,
//              style: new ol.style.Style({
 //                 stroke: new ol.style.Stroke({
//                      color: arrayLines[i][1],
 //                     width: arrayLines[i][2],
//                      lineDash: arrayLines[i][3]
//                  })
//              })
 //         });
 //         map.addLayer(vectorLineLayer);
 //     }// end for j=
//  }// end for i=
    </script>
    </body>
  </html>
  
